## Task 1

**a) Why does an arrival event need to generate a new arrival event?** **b) Which event should be generated by the start of the service (of a single service point)?**
- a) An arrival event need to generate a new arrival event inorder to continue enter new customers in system. Without this step, the system will stop receive customers and simulation would end prematurely.

- b)Service Completion event should be generated.

## Task 2
**Define the Event and EventList classes so that the EventList can be used to get the Event objects processed in the correct chronological order. The Event is associated with an event time as an essential piece of information, and it is essential that the next event in the event list can be retrieved on demand.**

```java
package task2;

import java.time.LocalDateTime;

public class EventTestProgram {
    public static void main(String[] args) {
        EventList eventList = new EventList();

        // Adding events
        eventList.addEvent(new Event("Event 1", LocalDateTime.of(2023, 10, 1, 10, 0)));
        eventList.addEvent(new Event("Event 2", LocalDateTime.of(2023, 9, 15, 9, 30)));
        eventList.addEvent(new Event("Event 3", LocalDateTime.of(2023, 11, 5, 14, 0)));

        // Retrieving and printing ordered events
        System.out.println("Ordered Events:");
        for (Event event : eventList.getOrderedEvents()) {
            System.out.println(event);
        }

        // Getting the next event
        System.out.println("\nNext Event:");
        System.out.println(eventList.getNextEvent());
    }
}
```
```java

package task2;

import java.util.ArrayList;
import java.util.List;
import java.util.PriorityQueue;

public class EventList {
    private PriorityQueue<Event> eventQueue;

    public EventList() {
        eventQueue = new PriorityQueue<>();
    }
    public void addEvent(Event event) {
        eventQueue.add(event);
    }
    public Event getNextEvent() {
        return eventQueue.poll(); // retrieves and removes the next event
    }
    public List<Event> getOrderedEvents() {
       // create copy of the priority queue to avoid modifying the original
        PriorityQueue<Event> copyQueue = new PriorityQueue<>(eventQueue);
        List<Event> orderedEvents = new ArrayList<>();
        while (!copyQueue.isEmpty()) {
            orderedEvents.add(copyQueue.poll());
        }
        return orderedEvents;
    }
}
```
```java
package task2;

import java.time.LocalDateTime;

public class EventTestProgram {
    public static void main(String[] args) {
        EventList eventList = new EventList();

        // Adding events
        eventList.addEvent(new Event("Event 1", LocalDateTime.of(2023, 10, 1, 10, 0)));
        eventList.addEvent(new Event("Event 2", LocalDateTime.of(2023, 9, 15, 9, 30)));
        eventList.addEvent(new Event("Event 3", LocalDateTime.of(2023, 11, 5, 14, 0)));

        // Retrieving and printing ordered events
        System.out.println("Ordered Events:");
        for (Event event : eventList.getOrderedEvents()) {
            System.out.println(event);
        }

        // Getting the next event
        System.out.println("\nNext Event:");
        System.out.println(eventList.getNextEvent());
    }
}
```
## Task3

```java
package task3;

public enum EventType {
    ARRIVAL,
    EXIT
}
```


```java
package task3;

import java.time.LocalDateTime;

public class Event implements Comparable<Event> {
    private String name;
    private LocalDateTime eventTime;
    private EventType eventType;

    public Event(String name, LocalDateTime eventTime, EventType eventType) {
        this.name = name;
        this.eventTime = eventTime;
        this.eventType = eventType;
    }

    public LocalDateTime getEventTime() {
        return eventTime;
    }

    public EventType getEventType() {
        return eventType;
    }

    public String getName() {
        return name;
    }

    @Override
    public int compareTo(Event other) {
        return this.eventTime.compareTo(other.eventTime);
    }
    @Override
    public String toString() {
        return "[" + eventType + "] " + name + " at " + eventTime;
    }
}

```

```java

package task3;

import java.util.PriorityQueue;
import java.util.List;
import java.util.ArrayList;

public class EventList {
    private PriorityQueue<Event> queue;

    public EventList() {
        queue = new PriorityQueue<>();
    }

    public void addEvent(Event event) {
        queue.add(event);
    }

    public Event getNextEvent() {
        return queue.poll();
    }

    public List<Event> getOrderedEvents() {
        PriorityQueue<Event> copy = new PriorityQueue<>(queue);
        List<Event> ordered = new ArrayList<>();
        while (!copy.isEmpty()) {
            ordered.add(copy.poll());
        }
        return ordered;
    }
}

```
```java

import java.time.LocalDateTime;

public class EventTest {
    public static void main(String[] args) {
        EventList eventList = new EventList();

        // a) Generate events with types
        eventList.addEvent(new Event("Train arrives", LocalDateTime.of(2025, 9, 3, 8, 0), EventType.ARRIVAL));
        eventList.addEvent(new Event("Passenger exits", LocalDateTime.of(2025, 9, 3, 8, 5), EventType.EXIT));
        eventList.addEvent(new Event("Bus arrives", LocalDateTime.of(2025, 9, 3, 9, 0), EventType.ARRIVAL));
        eventList.addEvent(new Event("Driver exits", LocalDateTime.of(2025, 9, 3, 9, 15), EventType.EXIT));

        // b) Remove and print the next event
        System.out.println("Next event to process:");
        System.out.println(eventList.getNextEvent());

        // c) Print remaining events in chronological order
        System.out.println("\nRemaining events in order:");
        for (Event e : eventList.getOrderedEvents()) {
            System.out.println(e);
        }
    }
}

```
